from __future__ import print_function
from __future__ import absolute_import
import numpy as np
from copy import deepcopy
from astropy.io import fits
from scipy.ndimage.filters import gaussian_filter

from lsst.eotest.fitsTools import fitsWriteto

<<<<<<< HEAD
def is_valid_aggressor(ccd, amp, ay, ax, threshold=100000., r=50):
    """Evaluate if identified spot is valid aggressor."""    
    imarr = ccd[amp].getImage().getArray()
    ny, nx = imarr.shape
    y, x = np.ogrid[-ay:ny-ay, -ax:nx-ax]
    mask = x*x + y*y >= r*r
    spot_arr = np.ma.MaskedArray(imarr, mask)

    return np.mean(spot_arr) > threshold
    
def find_aggressors(ccd, threshold=100000, gf_sigma=50):
    """Determine amplifier location of aggressor spots."""
    candidate_list = []
    for amp in ccd.keys():
        blurred = gaussian_filter(ccd[amp].getImage().getArray(), gf_sigma)
        y, x = np.unravel_index(blurred.argmax(), blurred.shape)
        
        if is_valid_aggressor(ccd, amp, y, x, threshold=threshold):
            candidate_list.append((amp, y, x))

    return candidate_list

def make_stamp(ccd, amp, y, x, l=200):
    """Get postage stamp for crosstalk calculations."""

    imarr = ccd.unbiased_and_trimmed_image(amp).getImage().getArray()
    maxy, maxx = imarr.shape

    ## Truncate at amplifier edges
    if y-l//2 < 0: 
        y0 = 0
    else:
        y0 = y-l//2
    if y+l//2 >= maxy: 
        y1 = maxy
    else:
        y1 = y+l//2
    if x-l//2 < 0: 
        x0 = 0
    else:
        x0 = x-l//2
    if x+l//2 >= maxx: 
        x1 = maxx
    else:
        x1 = x+l//2

    return deepcopy(imarr[y0:y1, x0:x1])

def crosstalk_model(coefficients, aggressor_array):
    """Create a crosstalk victim postage stamp from model."""

    ny, nx = aggressor_array.shape
    crosstalk_signal = coefficients[0]
    bias = coefficients[1]
    tilty = coefficients[2]
    tiltx = coefficients[3]

    Y, X = np.mgrid[:ny, :nx]
    model = crosstalk_signal*aggressor_array + tilty*Y + tiltx*X + bias
    return model

def crosstalk_model_fit(aggressor_stamp, victim_stamp, num_iter=5, nsig=2.0):
    """Perform a crosstalk model fit for given  aggressor and victim stamps."""

    coefficients = np.asarray([[0,0,0,0]])
    victim_array = np.ma.masked_invalid(victim_stamp)
    mask = np.ma.getmask(victim_array)

    for i in range(num_iter):
        #
        # Mask outliers using residual
        #
        model = np.ma.masked_where(mask, crosstalk_model(coefficients[0],
                                                         aggressor_stamp))
        residual = victim_array - model
        res_mean = residual.mean()
        res_std = residual.std()
        victim_array = np.ma.masked_where(np.abs(residual-res_mean) \
                                              > nsig*res_std, victim_stamp)
        mask = np.ma.getmask(victim_array)
        #
        # Construct masked, compressed basis arrays
        #
        ay, ax = aggressor_stamp.shape
        bias = np.ma.masked_where(mask, np.ones((ay, ax))).compressed()
        Y, X = np.mgrid[:ay, :ax]
        Y = np.ma.masked_where(mask, Y).compressed()
        X = np.ma.masked_where(mask, X).compressed()
        aggressor_array = np.ma.masked_where(mask, aggressor_stamp).compressed()
        #
        # Perform least-squares minimization
        #
        b = victim_array.compressed()/victim_array.std()
        A = np.vstack([aggressor_array, bias, Y, X]).T/victim_array.std()
        coefficients = np.linalg.lstsq(A, b)
        covar = np.matrix(np.dot(A.T, A)).I

    return np.append(coefficients[0], np.sqrt(covar.diagonal()))
        
class CrosstalkMatrix():

    def __init__(self, aggressor_sensor_id, victim_sensor_id=None, filename=None, namps=16):
        self.header = fits.Header()
        self.header.set('SENSOR1', aggressor_sensor_id)
        if victim_sensor_id is not None:
            self.header.set('SENSOR2', victim_sensor_id)
        else:
            self.header.set('SENSOR2', aggressor_sensor_id)
=======
    This routine is optimized for system crosstalk input, i.e., for
    which the aggressor amp has a single illuminated column.
    """
    #
    # Find bright column of aggressor amplifier.
    #
    # Set exptime and gain to unity so that the e- threshold used by
    # BrightPixels converts directly to DN.
    #
    exptime = 1
    gain = 1
    if dnthresh is None:
        image = ccd.unbiased_and_trimmed_image(aggressor_amp)
        median, stdev = get_stats(image, ccd.stat_ctrl)
        dnthresh = median + nsig*stdev
    bp = BrightPixels(ccd, aggressor_amp, exptime, gain, ethresh=dnthresh)
    pixels, columns = bp.find()

    if len(columns) > 1:
        raise RuntimeError("More than one aggressor column found.")

    agg_col = columns[0]
    agg_mean = column_mean(ccd, aggressor_amp, agg_col)[0]

    ratios = dict([(amp, column_mean(ccd, amp, agg_col)/agg_mean)
                   for amp in ccd])
    return ratios


def get_footprint(fp_set, min_fp_size, threshold):
    footprints = [fp for fp in fp_set.getFootprints()
                  if fp.getArea() >= min_fp_size]
    if len(footprints) > 1:
        message = "More than one spot image found in aggressor amplifier.\n"
        message += "      x     y     peak value  # pixels\n"
        for i, fp in enumerate(footprints):
            peak = [x for x in fp.getPeaks()][0]
            message += ('%2i  %4i  %4i     %6i       %4i\n'
                        % (i, peak.getIx(), peak.getIy(), peak.getPeakValue(),
                           fp.getArea()))
        message += "Threshold: %i\n" % threshold
        raise RuntimeError(message)
    fp = footprints[0]
    peak_value = max([x.getPeakValue() for x in fp.getPeaks()])
    return fp, peak_value


def extract_mean_signal_2(ccd, amp, footprint):
    masked_image = ccd.bias_subtracted_image(amp)
    stdev = afwMath.makeStatistics(masked_image, afwMath.STDEVCLIP,
                                   ccd.stat_ctrl).getValue()
    signal = 0
    npix = 0
    for span in footprint.getSpans():
        width = span.getX1() - span.getX0() + 1
        bbox = afwGeom.Box2I(afwGeom.Point2I(span.getX0(), span.getY()),
                             afwGeom.Extent2I(width, 1))
        subim = masked_image.Factory(masked_image, bbox)
        stats = afwMath.makeStatistics(subim, afwMath.SUM | afwMath.NPOINT,
                                       ccd.stat_ctrl)
        signal += stats.getValue(afwMath.SUM)
        npix += stats.getValue(afwMath.NPOINT)
    return np.array((signal/npix, stdev))


def extract_mean_signal(ccd, amp, footprint):
    maskarr = ccd[amp].getMask().getArray()
    image = ccd.bias_subtracted_image(amp)
    stdev = afwMath.makeStatistics(image, afwMath.STDEVCLIP,
                                   ccd.stat_ctrl).getValue()
    imarr = image.getImage().getArray()
    signal = 0
    npix = 0
    for span in footprint.getSpans():
        y = span.getY()
        for x in range(span.getX0(), span.getX1()+1):
            npix += 1
            if maskarr[y][x] == 0:
                signal += imarr[y][x]
    return np.array((signal/float(npix), stdev))


def detector_crosstalk(ccd, aggressor_amp, dnthresh=None, nsig=5,
                       signal_extractor=extract_mean_signal,
                       min_fp_size=50):
    """
    Compute detector crosstalk from a spot image in the aggressor
    amplifier. dnthresh is the threshold in DN for detecting the
    illuminated column in the aggressor amplifier; if set to None,
    then nsig*clipped_stdev above median is used for the threshold.
    """
    image = ccd.unbiased_and_trimmed_image(aggressor_amp)
    #
    # Extract footprint of spot image using nominal detection
    # threshold.
    #
    if dnthresh is None:
        median, stdev = get_stats(image, ccd.stat_ctrl)
#        dnthresh = median + nsig*stdev
        dnthresh = (np.max(image.getImage().getArray())
                    + median)/2.
#    print "dnthresh =", dnthresh
    threshold = afwDetect.Threshold(dnthresh)
    fp_set = afwDetect.FootprintSet(image, threshold)
    try:
        footprint, peak_value = get_footprint(fp_set, min_fp_size, dnthresh)
    except IndexError:
        raise RuntimeError('index error in get_footprint')

    agg_mean = signal_extractor(ccd, aggressor_amp, footprint)[0]
    ratios = dict([(amp, signal_extractor(ccd, amp, footprint)
                    / agg_mean) for amp in ccd])
#    for amp in ratios:
#        if ratios[amp][0] > 0.1:
#            ratios[amp] = (0, 0)
    return ratios


class CrosstalkMatrix(object):
    def __init__(self, filename=None, namps=16):
>>>>>>> master
        self.filename = filename
        self.namps = namps
        self._set_matrix()
        if self.filename is not None:
            self._read_matrix()

    def set_row(self, aggressor_amp, row):
        """Set matrix row from results dictionary"""
        for victim_amp in row.keys():
            self.matrix[:, aggressor_amp-1, victim_amp-1] = row[victim_amp]

    def _set_matrix(self):
        """Initialize crosstalk matrix as NaNs."""
        self.matrix = np.zeros((8, self.namps, self.namps), dtype=np.float)
        self.matrix[:] = np.nan

    def _read_matrix(self):
        """Read crosstalk matrix from file."""
        if self.filename[-5:] == '.fits':
            self._read_fits_matrix()
        elif self.filename[-5:] == '.yaml':
            self._read_yaml_matrix()
        else:
            raise ValueError('Crosstalk matrix file must be FITS or YAML filetype')

    def _read_fits_matrix(self):
        """Read crosstalk results from FITS file."""        
        hdulist = fits.open(self.filename)
        for i in range(8):
            self.matrix[i,:,:] = hdulist[i].data

    def _read_yaml_matrix(self):
        """Read crosstalk results from a YAML file."""
        raise NotImplementedError

    def write_fits(self, outfile=None, overwrite=True):
        """Write crosstalk results to FITS file."""
        if outfile is None:
            outfile = self.filename
        else:
            self.filename = outfile
        #
        # Save matrix results into separate HDUs
        #
        xtalk_hdu = fits.PrimaryHDU(self.matrix[0,:,:], header=self.header)
        bias_hdu = fits.ImageHDU(self.matrix[1,:,:], name='BIAS')
        tilty_hdu = fits.ImageHDU(self.matrix[2,:,:], name='TILT_Y')
        tiltx_hdu = fits.ImageHDU(self.matrix[3,:,:], name='TILT_X')
        xtalkerr_hdu = fits.ImageHDU(self.matrix[4,:,:], name='SIGMA_XTALK')
        biaserr_hdu = fits.ImageHDU(self.matrix[5,:,:], name='SIGMA_BIAS')
        tiltyerr_hdu = fits.ImageHDU(self.matrix[6,:,:], name='SIGMA_TILT_Y')
        tiltxerr_hdu = fits.ImageHDU(self.matrix[7,:,:], name='SIGMA_TILT_X')
        
        output = fits.HDUList([xtalk_hdu, bias_hdu, tilty_hdu, tiltx_hdu, 
                               xtalkerr_hdu, biaserr_hdu, tiltyerr_hdu, tiltxerr_hdu])
        fitsWriteto(output, outfile, overwrite=overwrite)

    def write_yaml(self, outfile, indent=2, crosstalkName='Unknown'):
        """Write crosstalk results to a YAML file."""

        ampNames = [str(i) for i in range(self.matrix.shape[1])]
        assert self.matrix.shape = (8, len(ampNames), len(ampNames))

        dIndent = indent
        indent = 0
        with open(outfile, "w") as fd:
            print(indent*" " + "crosstalk :", file=fd)
            indent += dIndent
            print(indent*" " + "%s :" % crosstalkName, file=fd)
            indent += dIndent

            for i, ampNameI in enumerate(ampNames):
                print(indent*" " + "%s : {" % ampNameI, file=fd)
                indent += dIndent
                print(indent*" ", file=fd, end='')

                for j, ampNameJ in enumerate(ampNames):
                    print("%s : %11.4e, " % (ampNameJ, coeff[i, j]), file=fd,
                          end='\n' + indent*" " if j%4 == 3 else '')
                print("}", file=fd)

                indent -= dIndent
                                           


 def writeCrosstalkCoeffs(outputFileName, coeff, amp_order, crosstalkName="Unknown", indent=2):
    """Write a yaml file containing the crosstalk coefficients

    The coeff array is indexed by [i, j] where i and j are amplifiers
    corresponding to the amplifiers in det

    Parameters
    ----------
    outputFileName : `str`
        Name of output yaml file
    coeff : `numpy.array(namp, namp)`
        numpy array of coefficients
    amp_order : 'list' of 'str'
        List of string names for the amplifiers (e.g. C00)
    ccdType : `str`
        Name of CCD, used to index the yaml file
        If all CCDs are identical could be the type (e.g. ITL)
    indent : `int`
        Indent width to use when writing the yaml file
    """

    dIndent = indent
    indent = 0
    with open(outputFileName, "w") as fd:
        print(indent*" " + "crosstalk :", file=fd)
        indent += dIndent
        print(indent*" " + "%s :" % crosstalkName, file=fd)
        indent += dIndent

        for i, ampNameI in enumerate(ampNames):
            print(indent*" " + "%s : {" % ampNameI, file=fd)
            indent += dIndent
            print(indent*" ", file=fd, end='')

            for j, ampNameJ in enumerate(ampNames):
                print("%s : %11.4e, " % (ampNameJ, coeff[i, j]), file=fd,
                      end='\n' + indent*" " if j%4 == 3 else '')
            print("}", file=fd)

            indent -= dIndent



        
    
    
                
            

        
            
            
        
        

            
            
        
        
